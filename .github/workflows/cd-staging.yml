name: Deploy to Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  STAGING_NAMESPACE: fullstack-staging
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_STAGING }}

jobs:
  # Pre-deployment checks
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      api-image: ${{ steps.images.outputs.api-image }}
      web-image: ${{ steps.images.outputs.web-image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check deployment conditions
        id: check
        run: |
          if [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "üöÄ Force deployment requested"
          else
            # Check if CI passed on the latest commit
            gh api repos/${{ github.repository }}/commits/${{ github.sha }}/check-runs \
              --jq '.check_runs[] | select(.name == "Continuous Integration") | .conclusion' > ci_status.txt
            
            if grep -q "success" ci_status.txt; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "‚úÖ CI passed, proceeding with deployment"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "‚ùå CI not passed, skipping deployment"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set image tags
        id: images
        run: |
          echo "api-image=${{ env.REGISTRY }}/${{ github.repository }}/api:${{ github.ref_name }}-${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "web-image=${{ env.REGISTRY }}/${{ github.repository }}/web:${{ github.ref_name }}-${{ github.sha }}" >> $GITHUB_OUTPUT

  # Database Migration
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Create migration job
        run: |
          export KUBECONFIG=kubeconfig
          
          # Create migration job from template
          envsubst < infrastructure/k8s/jobs/migration-job.yaml | kubectl apply -f -
          
          # Wait for migration to complete
          kubectl wait --for=condition=complete job/django-migration-${{ github.run_number }} \
            --namespace=${{ env.STAGING_NAMESPACE }} --timeout=600s
          
          # Check migration status
          if kubectl get job django-migration-${{ github.run_number }} \
            --namespace=${{ env.STAGING_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}' | grep -q True; then
            echo "‚ùå Migration failed"
            kubectl logs job/django-migration-${{ github.run_number }} --namespace=${{ env.STAGING_NAMESPACE }}
            exit 1
          else
            echo "‚úÖ Migration completed successfully"
          fi
        env:
          API_IMAGE: ${{ needs.pre-deployment.outputs.api-image }}
          NAMESPACE: ${{ env.STAGING_NAMESPACE }}
          JOB_ID: ${{ github.run_number }}

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment, database-migration]
    if: needs.pre-deployment.outputs.should-deploy == 'true'
    
    environment:
      name: staging
      url: https://staging.yourapp.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy API to staging
        run: |
          export KUBECONFIG=kubeconfig
          
          # Update API deployment
          kubectl set image deployment/django-api \
            django-api=${{ needs.pre-deployment.outputs.api-image }} \
            --namespace=${{ env.STAGING_NAMESPACE }}
          
          # Wait for rollout
          kubectl rollout status deployment/django-api \
            --namespace=${{ env.STAGING_NAMESPACE }} --timeout=600s

      - name: Deploy Web to staging
        run: |
          export KUBECONFIG=kubeconfig
          
          # Update Web deployment
          kubectl set image deployment/nextjs-web \
            nextjs-web=${{ needs.pre-deployment.outputs.web-image }} \
            --namespace=${{ env.STAGING_NAMESPACE }}
          
          # Wait for rollout
          kubectl rollout status deployment/nextjs-web \
            --namespace=${{ env.STAGING_NAMESPACE }} --timeout=600s

      - name: Update ConfigMaps and Secrets
        run: |
          export KUBECONFIG=kubeconfig
          
          # Apply updated configurations
          kubectl apply -f infrastructure/k8s/staging/ --namespace=${{ env.STAGING_NAMESPACE }}

      - name: Verify deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          # Check pod status
          kubectl get pods --namespace=${{ env.STAGING_NAMESPACE }}
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app=django-api --namespace=${{ env.STAGING_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod \
            -l app=nextjs-web --namespace=${{ env.STAGING_NAMESPACE }} --timeout=300s

  # Post-deployment Tests
  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: deploy-staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install test dependencies
        run: |
          cd tests && npm ci

      - name: Run smoke tests
        run: |
          cd tests && npm run test:smoke -- --env staging
        env:
          STAGING_API_URL: https://api-staging.yourapp.com
          STAGING_WEB_URL: https://staging.yourapp.com

      - name: Run health checks
        run: |
          # API health check
          curl -f https://api-staging.yourapp.com/health/ || exit 1
          
          # Web health check
          curl -f https://staging.yourapp.com/api/health || exit 1
          
          echo "‚úÖ All health checks passed"

      - name: Run basic functionality tests
        run: |
          cd tests && npm run test:staging-integration

  # Performance Monitoring
  performance-monitoring:
    name: Performance Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: post-deployment-tests
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Lighthouse CI
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: |
            https://staging.yourapp.com
            https://staging.yourapp.com/login
            https://staging.yourapp.com/dashboard
          configPath: './tests/lighthouse/lighthouserc.json'
          uploadArtifacts: true

      - name: Performance baseline check
        run: |
          # Run performance tests and compare with baseline
          cd tests && npm run test:performance -- --env staging --baseline

  # Rollback on Failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [deploy-staging, post-deployment-tests]
    if: failure()
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Rollback API deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîÑ Rolling back API deployment..."
          kubectl rollout undo deployment/django-api --namespace=${{ env.STAGING_NAMESPACE }}
          kubectl rollout status deployment/django-api --namespace=${{ env.STAGING_NAMESPACE }} --timeout=300s

      - name: Rollback Web deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîÑ Rolling back Web deployment..."
          kubectl rollout undo deployment/nextjs-web --namespace=${{ env.STAGING_NAMESPACE }}
          kubectl rollout status deployment/nextjs-web --namespace=${{ env.STAGING_NAMESPACE }} --timeout=300s

      - name: Verify rollback
        run: |
          export KUBECONFIG=kubeconfig
          
          # Check pod status after rollback
          kubectl get pods --namespace=${{ env.STAGING_NAMESPACE }}
          
          # Run basic health checks
          sleep 30
          kubectl exec -n ${{ env.STAGING_NAMESPACE }} deployment/django-api -- curl -f http://localhost:8000/health/ || echo "API health check failed"

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-staging, post-deployment-tests, performance-monitoring, rollback]
    if: always()
    
    steps:
      - name: Notify success
        if: ${{ needs.deploy-staging.result == 'success' && needs.post-deployment-tests.result == 'success' }}
        run: |
          echo "üöÄ Staging deployment completed successfully!"
          echo "Environment: https://staging.yourapp.com"
          echo "API: https://api-staging.yourapp.com"
          echo "Commit: ${{ github.sha }}"

      - name: Notify failure
        if: ${{ needs.deploy-staging.result == 'failure' || needs.post-deployment-tests.result == 'failure' }}
        run: |
          echo "‚ùå Staging deployment failed!"
          if [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "‚úÖ Rollback completed successfully"
          else
            echo "‚ùå Rollback also failed - manual intervention required"
          fi
          exit 1

      - name: Notify skipped
        if: ${{ needs.pre-deployment.outputs.should-deploy == 'false' }}
        run: |
          echo "‚è≠Ô∏è Staging deployment skipped - CI checks not passed"