name: Deploy to Production

on:
  push:
    branches: [main]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - production-blue
          - production-green
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  PRODUCTION_NAMESPACE: fullstack-production
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_PRODUCTION }}

jobs:
  # Production Readiness Check
  production-readiness:
    name: Production Readiness Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      api-image: ${{ steps.images.outputs.api-image }}
      web-image: ${{ steps.images.outputs.web-image }}
      deployment-strategy: ${{ steps.strategy.outputs.strategy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check production readiness
        id: check
        run: |
          # Check if this is a hotfix or emergency deployment
          if [[ "${{ github.ref_name }}" == hotfix/* ]] || [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "🚨 Emergency/Hotfix deployment - skipping some checks"
          else
            # Verify staging deployment success
            gh api repos/${{ github.repository }}/deployments \
              --jq '.[] | select(.environment == "staging") | select(.sha == "${{ github.sha }}") | .statuses_url' \
              | head -1 | xargs gh api \
              | jq -r '.[0].state' > staging_status.txt
            
            if grep -q "success" staging_status.txt; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "✅ Staging deployment successful, proceeding to production"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "❌ Staging deployment not successful, blocking production deployment"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set deployment strategy
        id: strategy
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production-blue" ] || [ "${{ github.event.inputs.environment }}" = "production-green" ]; then
            echo "strategy=blue-green" >> $GITHUB_OUTPUT
          else
            echo "strategy=rolling" >> $GITHUB_OUTPUT
          fi

      - name: Set image tags
        id: images
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          else
            TAG="main-${{ github.sha }}"
          fi
          
          echo "api-image=${{ env.REGISTRY }}/${{ github.repository }}/api:${TAG}" >> $GITHUB_OUTPUT
          echo "web-image=${{ env.REGISTRY }}/${{ github.repository }}/web:${TAG}" >> $GITHUB_OUTPUT

  # Security and Compliance Checks
  security-compliance:
    name: Security & Compliance
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: production-readiness
    if: needs.production-readiness.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run security compliance scan
        run: |
          # Run comprehensive security scans
          echo "🔒 Running security compliance checks..."
          
          # Check for secrets in code
          docker run --rm -v "$PWD:/path" zricethezav/gitleaks:latest detect --source="/path" --verbose
          
          # OWASP dependency check
          docker run --rm -v "$PWD:/src" owasp/dependency-check:latest \
            --scan /src --format JSON --out /src/dependency-check-report.json || true

      - name: Compliance validation
        run: |
          echo "📋 Validating compliance requirements..."
          
          # Check required files exist
          required_files=(
            "SECURITY.md"
            "PRIVACY.md" 
            "infrastructure/k8s/network-policies/"
            "infrastructure/k8s/pod-security-policies/"
          )
          
          for file in "${required_files[@]}"; do
            if [ ! -e "$file" ]; then
              echo "❌ Missing required file: $file"
              exit 1
            fi
          done
          
          echo "✅ Compliance validation passed"

  # Pre-production Testing
  pre-production-tests:
    name: Pre-production Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [production-readiness, security-compliance]
    if: needs.production-readiness.outputs.should-deploy == 'true' && github.event.inputs.skip_tests != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run production smoke tests
        run: |
          cd tests && npm ci
          npm run test:production-smoke

      - name: Load testing
        run: |
          # Run load tests against staging to validate production readiness
          cd tests && npm run test:load -- --env staging --duration 5m

      - name: Security penetration testing
        run: |
          # Run basic penetration tests
          cd tests && npm run test:security -- --env staging

  # Database Backup and Migration
  database-preparation:
    name: Database Preparation
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [production-readiness, security-compliance]
    if: needs.production-readiness.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Create database backup
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "💾 Creating production database backup..."
          
          # Create backup job
          envsubst < infrastructure/k8s/jobs/backup-job.yaml | kubectl apply -f -
          
          # Wait for backup to complete
          kubectl wait --for=condition=complete job/db-backup-${{ github.run_number }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=1200s
          
          echo "✅ Database backup completed"
        env:
          NAMESPACE: ${{ env.PRODUCTION_NAMESPACE }}
          JOB_ID: ${{ github.run_number }}

      - name: Test database migration (dry-run)
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🧪 Testing database migration (dry-run)..."
          
          # Create migration test job
          envsubst < infrastructure/k8s/jobs/migration-test-job.yaml | kubectl apply -f -
          
          # Wait for test to complete
          kubectl wait --for=condition=complete job/migration-test-${{ github.run_number }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s
          
          # Check test results
          if kubectl get job migration-test-${{ github.run_number }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}' | grep -q True; then
            echo "❌ Migration test failed"
            kubectl logs job/migration-test-${{ github.run_number }} --namespace=${{ env.PRODUCTION_NAMESPACE }}
            exit 1
          else
            echo "✅ Migration test passed"
          fi
        env:
          API_IMAGE: ${{ needs.production-readiness.outputs.api-image }}
          NAMESPACE: ${{ env.PRODUCTION_NAMESPACE }}
          JOB_ID: ${{ github.run_number }}

  # Blue-Green Deployment
  blue-green-deployment:
    name: Blue-Green Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [production-readiness, database-preparation, pre-production-tests]
    if: needs.production-readiness.outputs.deployment-strategy == 'blue-green'
    
    environment:
      name: production
      url: https://yourapp.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Determine target environment
        id: target
        run: |
          export KUBECONFIG=kubeconfig
          
          # Check current active environment
          current=$(kubectl get service production-service \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            -o jsonpath='{.spec.selector.version}')
          
          if [ "$current" = "blue" ]; then
            echo "target=green" >> $GITHUB_OUTPUT
            echo "inactive=blue" >> $GITHUB_OUTPUT
          else
            echo "target=blue" >> $GITHUB_OUTPUT
            echo "inactive=green" >> $GITHUB_OUTPUT
          fi
          
          echo "Current active: $current, Deploying to: $(cat $GITHUB_OUTPUT | grep target | cut -d= -f2)"

      - name: Deploy to inactive environment
        run: |
          export KUBECONFIG=kubeconfig
          TARGET="${{ steps.target.outputs.target }}"
          
          echo "🚀 Deploying to $TARGET environment..."
          
          # Update deployments with new images
          kubectl set image deployment/django-api-$TARGET \
            django-api=${{ needs.production-readiness.outputs.api-image }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }}
          
          kubectl set image deployment/nextjs-web-$TARGET \
            nextjs-web=${{ needs.production-readiness.outputs.web-image }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }}
          
          # Wait for rollout
          kubectl rollout status deployment/django-api-$TARGET \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s
          kubectl rollout status deployment/nextjs-web-$TARGET \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s

      - name: Run database migration
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🗄️ Running database migration..."
          
          # Create migration job
          envsubst < infrastructure/k8s/jobs/migration-job.yaml | kubectl apply -f -
          
          # Wait for migration to complete
          kubectl wait --for=condition=complete job/django-migration-${{ github.run_number }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s
        env:
          API_IMAGE: ${{ needs.production-readiness.outputs.api-image }}
          NAMESPACE: ${{ env.PRODUCTION_NAMESPACE }}
          JOB_ID: ${{ github.run_number }}

      - name: Validate inactive environment
        run: |
          export KUBECONFIG=kubeconfig
          TARGET="${{ steps.target.outputs.target }}"
          
          echo "🧪 Validating $TARGET environment..."
          
          # Get service endpoint for testing
          API_ENDPOINT=$(kubectl get service django-api-$TARGET-service \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Run health checks
          curl -f http://$API_ENDPOINT:8000/health/ || exit 1
          
          # Run smoke tests
          cd tests && npm run test:production-smoke -- --endpoint http://$API_ENDPOINT:8000

      - name: Switch traffic to new environment
        run: |
          export KUBECONFIG=kubeconfig
          TARGET="${{ steps.target.outputs.target }}"
          
          echo "🔄 Switching traffic to $TARGET environment..."
          
          # Update service selector to point to new environment
          kubectl patch service production-service \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            -p '{"spec":{"selector":{"version":"'$TARGET'"}}}'
          
          echo "✅ Traffic switched to $TARGET environment"

      - name: Monitor new environment
        run: |
          echo "📊 Monitoring new environment for 5 minutes..."
          
          # Monitor for 5 minutes
          for i in {1..10}; do
            sleep 30
            
            # Check health
            curl -f https://yourapp.com/api/health || exit 1
            curl -f https://api.yourapp.com/health/ || exit 1
            
            echo "Health check $i/10 passed"
          done
          
          echo "✅ Environment monitoring completed successfully"

  # Rolling Deployment
  rolling-deployment:
    name: Rolling Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [production-readiness, database-preparation, pre-production-tests]
    if: needs.production-readiness.outputs.deployment-strategy == 'rolling'
    
    environment:
      name: production
      url: https://yourapp.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Run database migration
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🗄️ Running database migration..."
          
          # Create migration job
          envsubst < infrastructure/k8s/jobs/migration-job.yaml | kubectl apply -f -
          
          # Wait for migration to complete
          kubectl wait --for=condition=complete job/django-migration-${{ github.run_number }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s
        env:
          API_IMAGE: ${{ needs.production-readiness.outputs.api-image }}
          NAMESPACE: ${{ env.PRODUCTION_NAMESPACE }}
          JOB_ID: ${{ github.run_number }}

      - name: Deploy API with rolling update
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🚀 Deploying API with rolling update..."
          
          # Update API deployment
          kubectl set image deployment/django-api \
            django-api=${{ needs.production-readiness.outputs.api-image }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }}
          
          # Wait for rollout with monitoring
          kubectl rollout status deployment/django-api \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s

      - name: Validate API deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🧪 Validating API deployment..."
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app=django-api --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=300s
          
          # Run health checks
          sleep 30
          curl -f https://api.yourapp.com/health/ || exit 1

      - name: Deploy Web with rolling update
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🚀 Deploying Web with rolling update..."
          
          # Update Web deployment
          kubectl set image deployment/nextjs-web \
            nextjs-web=${{ needs.production-readiness.outputs.web-image }} \
            --namespace=${{ env.PRODUCTION_NAMESPACE }}
          
          # Wait for rollout
          kubectl rollout status deployment/nextjs-web \
            --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=600s

      - name: Validate Web deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🧪 Validating Web deployment..."
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod \
            -l app=nextjs-web --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=300s
          
          # Run health checks
          sleep 30
          curl -f https://yourapp.com/api/health || exit 1

  # Post-deployment Validation
  post-deployment-validation:
    name: Post-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [blue-green-deployment, rolling-deployment]
    if: always() && (needs.blue-green-deployment.result == 'success' || needs.rolling-deployment.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run comprehensive production tests
        run: |
          cd tests && npm ci
          
          # Run full production test suite
          npm run test:production-full
          
          # Run performance validation
          npm run test:performance -- --env production --baseline
          
          # Run security validation
          npm run test:security -- --env production

      - name: Monitor application metrics
        run: |
          echo "📊 Monitoring application metrics..."
          
          # Check key metrics for 10 minutes
          for i in {1..20}; do
            sleep 30
            
            # Check response times
            response_time=$(curl -w "%{time_total}" -s -o /dev/null https://yourapp.com)
            if (( $(echo "$response_time > 2.0" | bc -l) )); then
              echo "⚠️ High response time: ${response_time}s"
            fi
            
            # Check error rates via health endpoint
            curl -f https://yourapp.com/api/health || echo "❌ Health check failed at iteration $i"
            
            echo "Metrics check $i/20 completed"
          done

  # Cleanup and Finalization
  cleanup:
    name: Cleanup and Finalization
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [blue-green-deployment, rolling-deployment, post-deployment-validation]
    if: always()
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Cleanup old resources
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🧹 Cleaning up old resources..."
          
          # Clean up old migration jobs (keep last 5)
          kubectl get jobs --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            --sort-by=.metadata.creationTimestamp \
            -o name | grep migration | head -n -5 | xargs -r kubectl delete --namespace=${{ env.PRODUCTION_NAMESPACE }}
          
          # Clean up old backup jobs (keep last 10)
          kubectl get jobs --namespace=${{ env.PRODUCTION_NAMESPACE }} \
            --sort-by=.metadata.creationTimestamp \
            -o name | grep backup | head -n -10 | xargs -r kubectl delete --namespace=${{ env.PRODUCTION_NAMESPACE }}

      - name: Update deployment records
        run: |
          echo "📝 Recording deployment information..."
          
          # Create deployment record
          cat > deployment-record.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "api_image": "${{ needs.production-readiness.outputs.api-image }}",
            "web_image": "${{ needs.production-readiness.outputs.web-image }}",
            "strategy": "${{ needs.production-readiness.outputs.deployment-strategy }}",
            "workflow_run": "${{ github.run_id }}"
          }
          EOF
          
          echo "Deployment record created"

  # Rollback on Failure
  emergency-rollback:
    name: Emergency Rollback
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [blue-green-deployment, rolling-deployment, post-deployment-validation]
    if: failure()
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Emergency rollback
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🚨 Initiating emergency rollback..."
          
          # Rollback API
          kubectl rollout undo deployment/django-api --namespace=${{ env.PRODUCTION_NAMESPACE }}
          kubectl rollout status deployment/django-api --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=300s
          
          # Rollback Web
          kubectl rollout undo deployment/nextjs-web --namespace=${{ env.PRODUCTION_NAMESPACE }}
          kubectl rollout status deployment/nextjs-web --namespace=${{ env.PRODUCTION_NAMESPACE }} --timeout=300s
          
          echo "✅ Emergency rollback completed"

      - name: Restore database if needed
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "🗄️ Checking if database rollback is needed..."
          
          # This would typically involve more sophisticated logic
          # to determine if database changes need to be reverted
          echo "Database rollback assessment completed"

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [production-readiness, blue-green-deployment, rolling-deployment, post-deployment-validation, emergency-rollback]
    if: always()
    
    steps:
      - name: Notify success
        if: ${{ (needs.blue-green-deployment.result == 'success' || needs.rolling-deployment.result == 'success') && needs.post-deployment-validation.result == 'success' }}
        run: |
          echo "🎉 Production deployment completed successfully!"
          echo "Environment: https://yourapp.com"
          echo "API: https://api.yourapp.com"
          echo "Strategy: ${{ needs.production-readiness.outputs.deployment-strategy }}"
          echo "Commit: ${{ github.sha }}"

      - name: Notify failure
        if: ${{ needs.blue-green-deployment.result == 'failure' || needs.rolling-deployment.result == 'failure' || needs.post-deployment-validation.result == 'failure' }}
        run: |
          echo "❌ Production deployment failed!"
          if [ "${{ needs.emergency-rollback.result }}" = "success" ]; then
            echo "✅ Emergency rollback completed successfully"
          else
            echo "🚨 Emergency rollback also failed - immediate manual intervention required"
          fi
          exit 1

      - name: Notify skipped
        if: ${{ needs.production-readiness.outputs.should-deploy == 'false' }}
        run: |
          echo "⏭️ Production deployment skipped - readiness checks not passed"