# Logstash Configuration for Production Logging
# Processes logs from Django, Next.js, Nginx, and system components

input {
  # Filebeat input for log files
  beats {
    port => 5044
  }

  # Direct syslog input
  syslog {
    port => 5000
  }

  # HTTP input for application logs
  http {
    port => 8080
    codec => json
  }

  # Redis input for real-time logs
  redis {
    host => "redis-master"
    port => 6379
    password => "${REDIS_PASSWORD}"
    key => "logstash"
    data_type => "list"
    codec => json
  }
}

filter {
  # Parse container logs
  if [container] {
    if [container][name] =~ /django/ {
      grok {
        match => { "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] %{LOGLEVEL:level} %{GREEDYDATA:logger}: %{GREEDYDATA:message}" }
        overwrite => [ "message" ]
      }
      
      # Parse Django request logs
      if [message] =~ /^"(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)/ {
        grok {
          match => { "message" => '"%{WORD:method} %{URIPATH:path}(?:%{URIPARAM:params})? HTTP/%{NUMBER:http_version}" %{NUMBER:status_code} %{NUMBER:response_size} "%{DATA:referrer}" "%{DATA:user_agent}" %{NUMBER:response_time}' }
        }
        
        mutate {
          convert => { 
            "status_code" => "integer"
            "response_size" => "integer"
            "response_time" => "float"
          }
        }
      }
      
      # Parse Django error logs
      if [level] == "ERROR" {
        grok {
          match => { "message" => "(?<error_type>\w+): %{GREEDYDATA:error_message}" }
        }
      }
    }
    
    if [container][name] =~ /nextjs/ {
      # Parse Next.js logs
      if [message] =~ /^\d{4}-\d{2}-\d{2}/ {
        grok {
          match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:message}" }
          overwrite => [ "message" ]
        }
      }
      
      # Parse Next.js request logs
      if [message] =~ /^(GET|POST|PUT|DELETE)/ {
        grok {
          match => { "message" => "%{WORD:method} %{URIPATH:path} %{NUMBER:status_code} in %{NUMBER:response_time}ms" }
        }
        
        mutate {
          convert => { 
            "status_code" => "integer"
            "response_time" => "integer"
          }
        }
      }
    }
    
    if [container][name] =~ /nginx/ {
      # Parse Nginx access logs
      grok {
        match => { "message" => '%{IPORHOST:remote_addr} - %{DATA:remote_user} \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{DATA:path} HTTP/%{NUMBER:http_version}" %{NUMBER:status_code} %{NUMBER:body_bytes_sent} "%{DATA:referrer}" "%{DATA:user_agent}" "%{DATA:x_forwarded_for}" rt=%{NUMBER:request_time} uct="%{DATA:upstream_connect_time}" uht="%{DATA:upstream_header_time}" urt="%{DATA:upstream_response_time}"' }
      }
      
      mutate {
        convert => { 
          "status_code" => "integer"
          "body_bytes_sent" => "integer"
          "request_time" => "float"
        }
      }
      
      # GeoIP enrichment
      geoip {
        source => "remote_addr"
        target => "geoip"
      }
    }
    
    if [container][name] =~ /postgres/ {
      # Parse PostgreSQL logs
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{NUMBER:pid}\]: \[%{NUMBER:line_num}-%{NUMBER:session_id}\] user=%{DATA:db_user},db=%{DATA:database},app=%{DATA:application},client=%{IPORHOST:client_ip} %{WORD:level}: %{GREEDYDATA:message}" }
        overwrite => [ "message" ]
      }
      
      # Parse slow query logs
      if [message] =~ /duration:/ {
        grok {
          match => { "message" => "duration: %{NUMBER:query_duration} ms statement: %{GREEDYDATA:sql_query}" }
        }
        
        mutate {
          convert => { "query_duration" => "float" }
        }
      }
    }
    
    if [container][name] =~ /redis/ {
      # Parse Redis logs
      grok {
        match => { "message" => "%{NUMBER:pid}:%{WORD:role} %{TIMESTAMP_ISO8601:timestamp} %{WORD:level} %{GREEDYDATA:message}" }
        overwrite => [ "message" ]
      }
    }
  }

  # Add common fields
  mutate {
    add_field => { "environment" => "${ENVIRONMENT:production}" }
    add_field => { "service_version" => "${SERVICE_VERSION:unknown}" }
  }

  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }
  }

  # Security log enrichment
  if [level] == "WARNING" or [level] == "ERROR" or [status_code] >= 400 {
    mutate {
      add_tag => [ "security_relevant" ]
    }
    
    # Detect potential attacks
    if [path] =~ /\.(php|asp|jsp|cgi)$/ or [user_agent] =~ /(sqlmap|nmap|nikto|burp|owasp)/ {
      mutate {
        add_tag => [ "potential_attack" ]
      }
    }
    
    # Detect brute force attempts
    if [path] =~ /login/ and [status_code] == 401 {
      mutate {
        add_tag => [ "failed_login" ]
      }
    }
  }

  # Performance monitoring
  if [response_time] {
    if [response_time] > 5000 {
      mutate {
        add_tag => [ "slow_response" ]
      }
    }
  }

  # Error categorization
  if [level] == "ERROR" {
    if [message] =~ /database|connection|timeout/ {
      mutate {
        add_field => { "error_category" => "database" }
      }
    } else if [message] =~ /memory|out of memory/ {
      mutate {
        add_field => { "error_category" => "memory" }
      }
    } else if [message] =~ /permission|access|denied/ {
      mutate {
        add_field => { "error_category" => "security" }
      }
    } else {
      mutate {
        add_field => { "error_category" => "application" }
      }
    }
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    index => "logs-%{+YYYY.MM.dd}"
    template_name => "logs"
    template_pattern => "logs-*"
    template => {
      "index_patterns" => ["logs-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 1
        "index.refresh_interval" => "30s"
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "level" => { "type" => "keyword" }
          "message" => { "type" => "text" }
          "container" => {
            "properties" => {
              "name" => { "type" => "keyword" }
              "id" => { "type" => "keyword" }
            }
          }
          "status_code" => { "type" => "integer" }
          "response_time" => { "type" => "float" }
          "remote_addr" => { "type" => "ip" }
          "geoip" => {
            "properties" => {
              "location" => { "type" => "geo_point" }
              "country_name" => { "type" => "keyword" }
              "city_name" => { "type" => "keyword" }
            }
          }
        }
      }
    }
  }

  # Send security events to separate index
  if "security_relevant" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "security-logs-%{+YYYY.MM.dd}"
    }
  }

  # Send performance metrics to separate index
  if [response_time] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "performance-logs-%{+YYYY.MM.dd}"
    }
  }

  # Debug output (remove in production)
  # stdout { codec => rubydebug }
}